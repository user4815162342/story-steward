#summary Project File Hierarchy and Formats
#labels Phase-Implementation

= Introduction =

Story Steward does not use on monolithic file to store it's data. This improves performance some, as only a little bit has to be loaded at a time, when it is needed. This is a description of the formats, it is not a full fledged specification.


= Details =

The lack of a single monolithic file means there is a specific folder hierarchy which the project must maintain, it also means that you have to be careful to copy all files when you are moving them around, and keep them in the same relative hierarchy.

== Project File Name ==

There is no default extension for the main project file, which is what is loaded. Currently, it is somewhat standard to use '.json' as the extension, because that defines the format of the content, however this is not required. You can give it whatever extension you want.

The filename of the project, before the extension, determines the path for all other files in the project. For example, if your file is "MyNovel.json", files and folders will be named with "MyNovel" as a prefix. 

_NOTE: that if you have a project file in the same directory named "MyNovel.manuscript", it's folder and file names will conflict with the first project._

If you have more than one period in the filename, only the last one will be used to mark the extension.

Hereafter, I use <filename> to reference the name of the file before the extension, and <extension> to indicate the extension of the project file.

== File Hierarchy ==

The file hierarchy for the project begins at the level of the primary project file. It is not currently possible to have more disconnected set up, and I do not foresee it every being possible. Just don't mess with the hierarchy, and everything should be fine. You can put a readme.txt file in the same folder if you want to make sure everyone knows to leave it alone.

The hierachy of the project is listed below. The formats of each file are explained later.

  * <filename>.<extension>: this is the primary project file.
  * <filename>.lock: this is a 'lock' file, explained below.
  * <filename>.contents\: this is a directory which contains content files used for scene contents and certain notes fields. 
    * <identifier>.htm: this would be a content file identified by the semi-random unique identifier used as a filename, and referenced in the project file.
  * <filename>.backup\: this is a directory which contains backup files.
    * project.everySave.<n>.json: This is a backup of the primary file file created before every save. The most recent backup is always numbered '0', with each previous backup numbered '1','2', etc. The maximum number of backups is 10, as defined in the source code.
    * project.everySession.<n>.json: This is a backup of the primary file created before the first save in every session.
    * <identifier>.everySave.<n>.htm: This is a backup of a content file created before each save of that content.
    * <identifier>.everySession.<n>.htm: This is a backup of a content file created before the first save of every session.

== Primary Project File Format ==

The syntax of the primary project file conforms to the JSON specifications.

The schema of the format is defined in a pseudo-JSON below. Conventions used:
  * name: <type> = specifies that the property 'name' contains an object of type 'type'.
  * name: "value" = specifies that the property 'name' must contain a string with the value 'value'.
  * [ <type> ] = specifies that the type is an array that contains 0 or more objects of type 'type'.
  * <type0>: <type1> = specifies that a property with an arbitrary name of type 'type0' (which must be a string or a number) contains an object of type 'type1'.
  * <@type> = specifies that the type is a <uid> which must reference an object of type 'type'.
  * type0|type1|type2 = specifies that objects of type 'type0', 'type1' or 'type2' are all allowed in this location.

All properties are optional. In general, defaults for values are standard for a type (string defaults to a blank string, objects to null, etc), although this varies and is described further in the source code.

Each object type may also have additional undocumented properties, to allow for future compatibility (i.e. I don't have to change the format identifier every time I want to add a new property). In theory, the application should keep these undocumented attributes intact.

The following primitive types are used:
  * <string>: represents a JSON string value.
  * <number>: represents a JSON numeric value.
  * <boolean>: represents a JSON boolean value.
  * <date>: represents a JSON string formatted in TODO: What is this format called: "Fri Jan 28 2011 10:45:35 GMT-0600 (Central Standard Time)"?
  * <uid>
  * <file>

project = {
  type: "project",
  uid: "project", // NOTE: this is pre-specified because there can only ever be one project.
  created: <date>,
  modified: <date>,
  name: <string>,
  description: <memo>,
  credits: [ <credit> ],
  content: [ <book> | <part> | <chapter> | <scene> ],
  notes: [ <note> ],
  journal: [ <journal-entry> ],
  persons: [ <person> ],
  places: [ <place> ],
  things: [ <thing> ],
  goals: [ <goal> ],
  customizations: {
    scene: {
      statuses: [ <string> ], // specifies the statuses that a scene can have.
      structures: {             // specifies the 'structure' of the scene (action, reaction, etc.),
        <string>: [ <string> ]  // and the labels for the structcomp fields based on that structure.
      },                             
      importances: [ <string> ], // specifies the importance of the scene (plot,subplot,exposition,etc.)
      ratings: [ <string> ], // specifies the ways in which a scene can be rated (for review statistics, etc.)
    }
    person: {
      roles: [ <string> ], // specifies the 'role' of the character (antagonist, protagonist, etc.)
      importances: [ <string> ], // specifies the importance of the scene (major, minor ,etc.)
      ratings: [ <string> ], // specifies the ways in which a character can be rated (for review statistics, etc.)
    }
  },
  interface: { // TODO: Store data in here regarding the size, position and current tab of various
               // parts of the interface, as much as possible should be remembered.
  }
}

credit = {
  type: "credit",
  uid: <uid>,
  name: <string>,
  biography: <memo>,
  role: <string> // author, editor, illustrator, etc.
}

book = {
  type: "content",
  subtype: "book",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  credits: [ <credit> ],
  doNotPublish: <boolean>,
  tags: [ <string> ],
  content: [ <part> | <chapter> | <scene> ]
}

part = {
  type: "content",
  subtype: "part",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  doNotPublish: <boolean>,
  credits: [ <credit> ],
  tags: [ <string> ],
  content: [ <chapter> | <scene> ]
}

chapter = {
  type: "content",
  subtype: "chapter",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  credits: [ <credit> ],
  doNotPublish: <boolean>,
  tags: [ <string> ],
  content: [ <scene> ]
}

scene = {
  type: "content",
  subtype: "scene",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  begins: <date>,
  ends: <date>,
  viewpoint: <@uid>, 
  setting: <@uid>,
  people: [ <@uid> ],
  places: [ <@uid> ],
  things: [ <@uid> ],
  notes: <file>, // allows you to grow to some very large notes. the memos are meant
                 // to be small (and should be kept this way).
  lastWordCount: <number>,
  tags: [ <string> ], 
  status: <string>, // must be a valid status, or treated as null.
  structure: <string>, // must be a valid scene kind, or treated as null.
  importance: <string>, // must be a valid scene importances, or treated as null.
  ratings: [ <number> ], // ratings match the order in the lookup
  doNotPublish: <boolean>,
  goal: <memo>,
  conflict: <memo>,
  disaster: <memo>,
  reaction: <memo>,
  dilemma: <memo>,
  decision: <memo>,
  text: <file> // can't really call this 'content', as that would cause confusion with 
               // the 'content' property of other content types (which contain children,
               // not text)  
}

note = {
  type: "note",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  text: <file>, 
  subnotes: [ <note> ],
  tags: [ <string> ]
}

journal-entry = {
  type: "journal",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  posted: <date>,
  name: <string>,
  text: <file>,
  tags: [ <string> ]
}

person = {
  type: "person",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  fullName: <string>,
  aliases: [<string>,
  isMajor: <boolean>,
  description: <memo>,
  biography: <file>,
  notes: <file>,
  role: <string>, // must be a valid character role, or treated as null.
  importance: <string>, // must be a valid character importance, or treated as null.
  ratings: [ <number> ], // ratings match the order of the rating lookup
  motivation: <memo>,
  goal: <memo>,
  conflict: <memo>,
  epiphany: <memo>,
  tags: [ <string> ],
}


Character analysis should be motivation, goal, conflict, epiphany.

place = {
  type: "place",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  description: <memo>,
  background: <file>,
  notes: <file>,
  tags: [ <string> ],
}

thing = {
  type: "thing",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  aliases: [<string>,
  description: <memo>,
  background: <file>,
  notes: <file>,
  tags: [ <string> ],
}

goal = {
  type: "goal",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  what: <@book|@part|@chapter>,
  comments: <memo>,
  starting: <date>,
  ending: <date>,
  startingWordCount: <number>, // specifies the total word count at the beginning, which
                               // can be used to reduce the bounds of the chart.
  targetWordCount: <number>, // specifies the total word count of all scenes at the specified status.
                             // if targetStatus is null, then all scenes are counted.
  history: [ 
    {
      uid: <uid>,
      when: <date>,
      wordCount: <number>, // the total word count of all scenes being counted. NOTE: Only
                           // scenes which are 'publishable' are counted. If the scene, or the
                           // books, parts or chapters which contain it are marked 'doNotPublish'
                           // the scene will not be counted.
    } 
  ]
}