TODO:
-- Try to upload deploy file to Google Code
-- Move these issues and documentation to Google Code

TODO: Once SVN, or whatever, is set up, need to make sure the revision number gets into the 'version'
file. Use http://svnbook.red-bean.com/en/1.4/svn.ref.svnversion.re.html, somehow.

TODO: Once I have an issue tracker, move all TODO's and FUTURE's to it, and probably put 
the other stuff up on a Wiki or something.

FUTURE: If I were to simply search for dojo.requires in all of the javascript files,
     then I could insert them into the dojo profile myself, and I wouldn't have to
     keep them recorded twice.
     
TODO: It would be nice to have a 'words written this session' as well. This would get
updated when the goals are updated only, just as the word count is only updated when
goals are started.

TODO: Add a 'dontShowInLookup' attribute to tags, so that one can remove tags
which aren't commonly used, without having them being added back again the
next time they are used. This is really only necessary once I have editing of
lookup values.

TODO: Need to work on reports and tools.

TODO: Work on editing the lookup values and tags. 

TODO: NOTE: On rich text editors:
- There are three three types of fields that make use of a rich text editor. Certain
editor plugins and buttons are not available on all of them, for various reasons.
1) Memo: These are intended to be short text fields, formatted text is only included 
as a convenience to allow font style changes to mark things such as emphasis. 
The buttons available for these editors reflects this, having limited functionality.
2) Content: These fields contain text that may be published someday. As this application
is *not* a Word Processor or Document Publishing system, it is not necessary to need
a lot of fancy formatting, and in fact such features are seen as distracting
by many writers. Note that the hilite tool, which would normally be seen as extraneous
can be extremely useful for proof-reading, so it has been left in.
3) Notes: These fields are intended for the user to use for research, outlines, ideas,
and basically anything else which isn't going to be published. In order to facilitate
organization of these notes, users may need numerous additional features which are not
needed for content or memos.
 

TODO: I've chosen the Apache Software License for the following reasons:
- It is one that is considered popular, widely used and has a strong community, according
to http://www.opensource.org/licenses/category.
- It does not require modified or redistributed copies to retain this license.
- Also, it does not require works which make use of copies or modificatios to retain this license.
- It is recommended as an available license by Google Code.
- It does not require distribution of a "source" form.
- It is more precise about its terms.
- It does allow me to change the terms of the license in a future release.
 
Chose not to use the following:
- Modified/New BSD License
-- Not precise about all terms.
- MIT/X11 License
-- Not precise about all terms.
- Simplified/FreeBSD BSD License
-- Not recommended by Google Code
- GNU GPL v 2
-- requires modified redistributed copies to retain the GPL
-- requires source code distribution
- GNU GPL v 3
-- requires modified redistributed copies to retain the GPL
-- requires source code distribution
- GNU LGPL v 2.1
-- requires modified redistributed copies to retain the GPL
- GNU LGPL v 3
-- requires modified redistributed copies to retain the GPL
- Mozilla Public License
-- Not GPL Compatible
- Common Development and Distribution License
-- Not GPL Compatible
-- Not recommended by Google Code
- Eclipse Public License
-- Not GPL Compatible


NOTE: Use Firefox to debug directly, but against the aptana server. This gets around 
a strange error that's developed that makes this impossible from Aptana itself, and
also gives me access to Firebug.

TODO: When I add in update abilities to http, I think the appropriate mechanism
for handling CLOBs is to cache them, and then save them when the iohandler saves
everything else. This would not be unexpected by the user, since he isn't pressing
save to save things, but is only closing and opening tabs. This would also speed
up performance, as well as limit the amount of network activity and as a bonus, this
also means getting the text after the first get doesn't require a network connection.
The only problem with this issue is potential multi-user performance, but that's
probably out of scope for this project anyway.

FUTURE: It might be better to have more of the data source located on the server,
rather than stored in memory. This will reduce the footprint of an on-line only
version, which may be necessary for more limited devices. This would speed the
application up a bit on loading and saving, although make everything else a
little bit slower. This could essentially mean re-architecting the ProjectData
layer, but it could be more easily done by replacing the ItemFileWriteStores
with a new type of Data Store.

TODO: Mobile version:
- it shouldn't be too difficult to create an 'index-m.html' or something like that
that would be compatible. Put the 'contentTree', etc. in various dialogs instead.
Create new buttons with 'onclick' inline in the index which show these dialogs.
Put the other toolbar buttons in a sort of 'menu' toolbar.
- A small change to the DataItemViewer code can have it load a slightly different
screen in 'mobile' mode. The screens would be broken up into more tabs, etc.

TODO: Can't get this to work properly on the file scheme in IE. When I do this,
and attempt to load an entity in a tab, I get the error below. I 
suspect this has something to do with doing an xhr on the local file system,
when the template is loaded. My current solution is to finally say that the
application is not supported under this configuration.
A better solution might be to inline the template code into subclasses of a DataItemViewer.
This could be done with the dojo build system once I understand a lot more about that.
This would help me solve the issue where my component scripts are required in the index.html
file in IE, as well.

  Message: System error: -2146697211.
  Line: 258
  Char: 5
  Code: 0
  URI: file:///T:/Customers/TownsEdgeTechnology/projects/AuthorOrganizer/lib/dojo/dojo/_base/_loader/hostenv_browser.js



TODO: Bug in dragging and dropping: (ForestStoreModel, may be cause by errors occurring
at different points)
- if an item is at the root, and is moved into a 'child', the
item is still retained at the root, creating multiple copies of the item
(or perhaps they're just links, either way I don't like it).
- If items at the root level are dragged around, I can't get them to
change order, even though it shows things being accepted.
- I also can't get items to be dragged from inside a node to go
outside and into the root -- these items just disappear.
- When I'm dragging and dropping, and an error occurs, it leaves the
drag-drop tooltip lying around for some reason.
- ForestStoreModel contains a lot of comments about how the developer should
override this or that function... this is probably what I need.



TODO: Bug in the DataGrid:
- 1. When I move an item, it doesn't change the grid
(possibly, have to do something in onSet of DataGrid? But then the datagrid
has to know... Perhaps an alternative is that I need to have a sort order
and make sure that gets enforced in DataGrid) Really, the answer is a data store
mechanism that supports ordering and moving items, but then I have to update
the various UI components to work with that as well. 
--- Basically, as part of 'binding' the DataGrid, add an onSet listener for
the parent item and field (the DataViewer *does* knw about that part), and have
it reset the filter when this changes. I'd think it would refresh the data, not sure...
--- Another option is to have an 'order' number in the list, with each new item getting
a new one, and when things are moved, the numbers are re-ordered appropriately. 

TODO: Context Menus:
- on each tree view:
  - new child for each possible child type
  - new sibling for each possible type (will put it in the most recent possible parent)
  - delete item
  - show item
  - move item up
  - move item down
  - move item up and in
  - move item down and in
  - move item out
- on person, places or things:
  - add to current scene
- on the tabs:
  - close
  - close others
  - close all

FUTURE: Ideas for the journal entries:
- Ability to synchronize with a blog, or at least post entries there (this should be done through a plugin, somehow)
- Automatically record the current word count and other information in the journal.

TODO: Custom fields:
- Looking at requests for similar software, this seems to be a very common request.
In order to be useful, these custom fields would have to be visible in the grids,
not just on a separate tab on the entity. Not sure if it's necessary to establish
constraints: it's the users field, they can do with it as they want. (Although
a plugin system could help people make programmatic additions.) But, the user
does need to be able to specify a type (supported types would be: 'memo', 'text',
'number', 'date', 'time'.). If I also specify where they would appear, then I
can start turning *all* of the fields into custom fields.

TODO: When a 'tab' is selected, the tree node should be selected as well.

FUTURE: 
- Support additional books, as well as parts in the interface. Possibly, I can just put 
a button on the project info to create new books and parts, to be placed at the
root. New parts could also be created from the book, in which case they'll be 
children of that book.
- Support multiple authors for projects, and separate, multiple authors for books, parts and chapters.

TODO: Then, work on reporting.

TODO: It would be cool if, in memo fields at least, if not files, it were possible to insert
javascript links which would automatically open up the tab for other items in the database.

TODO: For the tree views, possibly create buttons which open up all items as a grid
in a new tab.

TODO: It would be nice to able to 'timeshift' or 'version control' content in a scene.
Although I could just have this hooked up to a version control system, an option to
choose an old version of a file would be nice. The data might be stored in the same
file name with a .old.0., .old.1., etc extension code. This would make it easy to
'try' things out. It might even be nice to be able to view both at once, including
differences, but that's even further out there.

TODO: I should make use of a JSON schema, or something like that, to do an idiot-check
of the file format before saving and after loading.

==== DATA FORMAT AND STRUCTURE ===		

--- File Format Grammar ---

All files will be in a standard JSON format. These are defined as a sort of pseudo-JSON/BNF code, 
with the following additional constructs:

name: <type> = specifies that the property 'name' is of type 'type'.
[ <type> ] = specifies an array that contains 0 or more objects of type 'type'.
{: <type> } = specifies a name value map which contains 0 or more members of type 'type'.
<@type> = specifies that the object is of 'type', but this is a reference to one stored elsewhere. The reference
will actually be done based on a unique key in an 'id' property.

All properties are optional, in general, defaults for values are standard for a type. Defaults
for arrays are empty arrays and hashmaps are empty objects. Otherwise, the default is going
to be 0, empty string, false, etc.

Each object type may also have additional undocumented properties, to allow for future compatibility.
If possible, these properties should be maintained through the lifetime of the object. The same
goes for 'nested' objects.


project = {
  type: "project",
  uid: "project", // NOTE: this is pre-specified because there can only ever be one project.
  created: <date>,
  modified: <date>,
  name: <string>,
  description: <memo>,
  credits: [ <credit> ],
  content: [ <book> | <part> | <chapter> | <scene> ],
  notes: [ <note> ],
  journal: [ <journal-entry> ],
  persons: [ <person> ],
  places: [ <place> ],
  things: [ <thing> ],
  goals: [ <goal> ],
  customizations: {
    scene: {
      statuses: [ <string> ], // specifies the statuses that a scene can have.
      structures: {             // specifies the 'structure' of the scene (action, reaction, etc.),
        <string>: [ <string> ]  // and the labels for the structcomp fields based on that structure.
      },                             
      importances: [ <string> ], // specifies the importance of the scene (plot,subplot,exposition,etc.)
      ratings: [ <string> ], // specifies the ways in which a scene can be rated (for review statistics, etc.)
    }
    person: {
      roles: [ <string> ], // specifies the 'role' of the character (antagonist, protagonist, etc.)
      importances: [ <string> ], // specifies the importance of the scene (major, minor ,etc.)
      ratings: [ <string> ], // specifies the ways in which a character can be rated (for review statistics, etc.)
    }
  },
  interface: { // TODO: Store data in here regarding the size, position and current tab of various
               // parts of the interface, as much as possible should be remembered.
  }
}

credit = {
  type: "credit",
  uid: <uid>,
  name: <string>,
  biography: <memo>,
  role: <string> // author, editor, illustrator, etc.
}

book = {
  type: "content",
  subtype: "book",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  credits: [ <credit> ],
  doNotPublish: <boolean>,
  tags: [ <string> ],
  content: [ <part> | <chapter> | <scene> ]
}

part = {
  type: "content",
  subtype: "part",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  doNotPublish: <boolean>,
  credits: [ <credit> ],
  tags: [ <string> ],
  content: [ <chapter> | <scene> ]
}

chapter = {
  type: "content",
  subtype: "chapter",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  credits: [ <credit> ],
  doNotPublish: <boolean>,
  tags: [ <string> ],
  content: [ <scene> ]
}

scene = {
  type: "content",
  subtype: "scene",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>, 
  description: <memo>, 
  begins: <date>,
  ends: <date>,
  viewpoint: <@uid>, 
  setting: <@uid>,
  people: [ <@uid> ],
  places: [ <@uid> ],
  things: [ <@uid> ],
  notes: <file>, // allows you to grow to some very large notes. the memos are meant
                 // to be small (and should be kept this way).
  lastWordCount: <number>,
  tags: [ <string> ], 
  status: <string>, // must be a valid status, or treated as null.
  structure: <string>, // must be a valid scene kind, or treated as null.
  importance: <string>, // must be a valid scene importances, or treated as null.
  ratings: [ <number> ], // ratings match the order in the lookup
  doNotPublish: <boolean>,
  goal: <memo>,
  conflict: <memo>,
  disaster: <memo>,
  reaction: <memo>,
  dilemma: <memo>,
  decision: <memo>,
  text: <file> // can't really call this 'content', as that would cause confusion with 
               // the 'content' property of other content types (which contain children,
               // not text)  
}

note = {
  type: "note",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  text: <file>, 
  subnotes: [ <note> ],
  tags: [ <string> ]
}

journal-entry = {
  type: "journal",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  posted: <date>,
  name: <string>,
  text: <file>,
  tags: [ <string> ]
}

person = {
  type: "person",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  fullName: <string>,
  aliases: [<string>,
  isMajor: <boolean>,
  description: <memo>,
  biography: <file>,
  notes: <file>,
  role: <string>, // must be a valid character role, or treated as null.
  importance: <string>, // must be a valid character importance, or treated as null.
  ratings: [ <number> ], // ratings match the order of the rating lookup
  motivation: <memo>,
  goal: <memo>,
  conflict: <memo>,
  epiphany: <memo>,
  tags: [ <string> ],
}


Character analysis should be motivation, goal, conflict, epiphany.

place = {
  type: "place",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  description: <memo>,
  background: <file>,
  notes: <file>,
  tags: [ <string> ],
}

thing = {
  type: "thing",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  aliases: [<string>,
  description: <memo>,
  background: <file>,
  notes: <file>,
  tags: [ <string> ],
}

goal = {
  type: "goal",
  uid: <uid>,
  created: <date>,
  modified: <date>,
  name: <string>,
  what: <@book|@part|@chapter>,
  comments: <memo>,
  starting: <date>,
  ending: <date>,
  startingWordCount: <number>, // specifies the total word count at the beginning, which
                               // can be used to reduce the bounds of the chart.
  targetWordCount: <number>, // specifies the total word count of all scenes at the specified status.
                             // if targetStatus is null, then all scenes are counted.
  history: [ 
    {
      uid: <uid>,
      when: <date>,
      wordCount: <number>, // the total word count of all scenes being counted. NOTE: Only
                           // scenes which are 'publishable' are counted. If the scene, or the
                           // books, parts or chapters which contain it are marked 'doNotPublish'
                           // the scene will not be counted.
    } 
  ]
}


data types:
- string: a normal JavaScript string type.
- number: a normal Javascript number type.
- boolean: a normal JavaScript boolean type.
- date: a normal Javascript Date type.
- memo: an HTML fragment that is stored in the data itself, as it isn't expected to get too large.
  There is probably an artificial limit of 500 words on this.
- uid: represents a unique identifier, at least unique within the application, if not globally.
- @uid: represents a reference to a unique identiefier, identifying another object.
- file: specifies that the content (an HTML fragment) is stored in a separate file. The value of
  this field is the name of the file relative to where the project keeps its files. It is generated
  internally as a guid as soon as the data is actually needed.

===== User Interface ===

  Top: Toolbar
    New Project, Open Project, Reopen Project, Save
	New Scene, New Note, New Character, New Place, New Item
	Inspiration (Oblique Strategies or configurable Quote of the Day).
	Full Screen (Applying the Browser's Full Screen may also do this) Hides all parts of the document 
	  except the current content pane. Puts three task buttons in the corner: return to regular screen,
	  choose view, and choose tab.
  Left Sidebar:
    Accordion Bar, each one generally has a 'list' below it, clicking on the list item opens/selects a 
	     tab in the content pane. If possible, a system button on the accordion bar opens up a 
		 larger 'grid' of the items. Another system button might let you 'filter' on the items
		 base on certain specific fields (including tags). Another system button would let you
		 'add' items. System buttons on each item would allow 'delete' or 'rename'.
		 It should be possible to 'drag and drop' items. Within the same context, this simply
		 changes their order or position. In other contexts, this does things like adding a 
		 character to a scene. 
	   Content:
	     TreeView, with scenes organized into chapters then parts then books.
		 If there is only one book, then there is no 'book' at the root, and the books details are
		 the same as the 'project'. If there is only one part in a given book, then there are no
		 parts shown, and the part details are the same as the book. If there is only one chapter in
		 a given part, then the chapter is not shown and the chapter details are the same as the
		 part.
		 When a book, part or chapter or scene is clicked, the appropriate content window for that
		 item is displayed.
	   Notes:
	     TreeView, with notes grouped into 'subnotes', etc. Notes can be text, or they can be resources.
		 More than likely, they'll just be HTML files with embedded content. 
		 One particular type of note is called a 'journal'. This one has a date on it.
	   Persons:
	     Lists all characters. I can't think of any way to put these into trees, 'character links' 
		 can be navigated through in the content.
	   Places:
	     Lists all places.
	   Things:
	     Lists all 'props'.
	   Tools:
	     Reports:
		     Work Schedule Report
			 Synopsis Report
			 Character Report
			 Location Report
			 Item Report
			 Rankings/Status Chart (shows a line or bar chart of scenes indicating the rankings, 
			                        the status (shown as a 'progress' bar from lowest status 
			                        to highest), and the word counts of the scenes in order
			                        they appear in the books.)
		 Storyboard (shows scene summaries on a card and lets you drag and drop)
		 Goals (let's you set goals, and shows charts which show the progress on these goals)
		 Search (let's you search through all items for certain text, and lists the results in
		         a way that lets you double-click on an item to open it up.).
		 Tasks: (shows some system tasks:
		         - automatically add characters, locations, items to scenes where they are mentioned.
				 - work with orphan, duplicate scenes.
				 - word usage count
				 - export?
				 - backup
         System Settings: (shows some settings for the application: autosave, autobackup, 
		         reopen last project, viewing options, configure some of the toolbar to
				 put in some quick tasks)
  Center:
  	Shows a tabbed view of content panels. Each tab contains a different content panel. The exact appearance
	of each item depends on the content type. Many content panels have different 'views' (such
	as properties, etc.) or 'pages'. Buttons for these appear at the bottom of each item.
	NOTE: By default, the first thing that will show up in a new and empty project will be the project
	properties content pane.
  Right Sidebar:
    This is an optional sidebar that allows for additional tools: dictionaries and 
	thesauruses are the only thing I can think of right now. However, it should be possible
	to add to this using plug-ins.
  Bottom: Status Bar
    Displays version, word count, words written today.

=== Future changes: ===

FUTURE:
The first revision of this application will use data on a local file system ("file" 'protocol'),
using browser-based proprietary commands to gain appropriate security and access the file system,
where this is not normally possible in a browser (i.e. listing files, saving files). 

A later revision will have data available over the web, on the "http" protocol. Updates will
be made using a REST-based PHP script interface. This avoids the browser having to load everything
in the project data in, make changes, and then post the results. This mechanism is also
more efficient on a local project, as it speeds up saving of data if you don't have to
load it first. There is one necessary exception, the 'index' file, listed below.

Both options will also allow a read-only mode, where files in the project may not be modified.
This read-only mode will be on if browser security prevents access to the local file system,
or the server is not set up with appropriate scripts for doing updates.

Finally, both versions will be compatible. It should be possible to move a local project up
to a web server using basic file transfer mechanisms, without having to modify the files or
pack them into a different format. The remote project will be read-only without the scripts,
but the project will be the same.

In order to make it easier to convert to the REST interface, as well as make it easier to
convert a local project to a remote project without needing special scriptiong, each data
'item' will be stored in a separate file. This allows the local file data access to be able
to simply write out a single file when data is changed.

The file structure would basically look something like this:
<name>.novel.project (would contain just the project specs)
<name>.novel.index (would contain a list of all files, broken into categories (files may
                    appear more than once). This file serves as both a mechanism for
                    determined the names of files, but also for quickly finding files
                    based on certain attributes (name, tag, etc.). We may have to have 
                    more than one of these to make it work, though, for each type of 
                    index, to reduce the amount of 'load, rewrite, and save' operations).
<name>.novel.<uid>.data (would contain a data item)
<name>.novel.<uid>.html (would contain a formatted HTML document linked by a data item.)

Possible further information:
The directory structure of the project is listed below, where <name> represents the name
of the project, and <uid> represents a unique ID for a data object. Files containing a
<uid> will be repeated for each object in the project.

The <name> allows multiple projects to be stored in the same directory. This is not
recommended, but it will not effect the efficiency of the program. It will, however,
effect the speed of directory listing commands outside of this program, and could easily
run into file system limits.

* <name>.novel.project

This file contains the root information about the project. See type <project> in the
file format grammar.

* <name>.novel.index 

This file contains a list of other files available in the project. See type <index> in
the file format grammar.

Although it is possible to retrieve a list of files in a local directory (with appropriate
security permission, <http://www.tiddlytools.com/#ShowLocalDirectory>), and it is possible
to get a list of files in a server directory (with appropriate server configuration, although
the return format is not standard), both of these require special configuration, which might
be unavailable. Since the application should be able to fall back to a 'read only' mode in
a minimal configuration environment, it is necessary to have an 'index' file of all of the
files in a known format. 

This file *would* have to be loaded in and updated when changes 
are made, and is read in when the data is read in. This file *should* be the final authority
on what data is in the project. Files not in the project may still appear in the file system,
but not be listed here. Attempts to synchronize these files will not be in scope of this
project. However, as they are all text-based, it should be a simple matter for someone
to do manually, or with a simple script.

* <name>.novel.lock

This file appears only if the project is open for modification. Its contents are yet to be
determined, but in theory could be used to ensure that a session that closes abnormally can 
be re-entered. Until the program has this mechanism, the appearance of this file means that
the project should not be opened for editing.

This file also has an additional use. When the application starts to load a project, if 
there is any reason it can not create this file, then the application will automatically know
it is to access the data read-only. Reasons why this file might not be created include
the possibility that it already exists, as well as that the browser is not configured to
allow write access, or the browser is not supported for allowing write access. All of these
are valid reasons to open it up read-only. 

* <name>.novel.<uid>.data

Files with this format contain data in one of the root types listed in the grammar below, except
<index> and <project>. Note that, for future compatibility purposes, this file may contain data
fitting an object type which is unknown to the application.


    
==== Available Icons in Tundra Theme ====
dijitIconApplication
dijitIconBookmark
dijitIconChart
dijitIconConfigure
dijitIconConnector
dijitIconCopy
dijitIconCut
dijitIconDatabase
dijitIconDelete
dijitIconDocuments
dijitIconEdit
dijitIconEditProperty
dijitIconEditTask
dijitIconError
dijitIconFile
dijitIconFilter
dijitIconFolderClosed
dijitIconFolderOpen
dijitIconFunction
dijitIconKey
dijitIconMail
dijitIconNewTask
dijitIconPackage
dijitIconPrint
dijitIconSample
dijitIconSave
dijitIconSearch
dijitIconTable
dijitIconTask
dijitIconUndo
dijitIconUsers
