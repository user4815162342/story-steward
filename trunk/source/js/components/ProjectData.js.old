// From before I got rid of the 'TagList' object and switched to plain string arrays.
dojo.provide("my.ProjectData");
dojo.require("dojo.data.ItemFileWriteStore");
dojo.declare("my.ProjectData", null, {

    TypeLookup: {
        "content": {
            isAbstract: true
        },
        "project": {
            form: "ProjectViewer",
            baseType: "project",
            typeLabel: "Project",
            defaultValue: {},
            allowedParents: [],
            childrenAttributes: []
        },
        "book": {
            form: "ContentContainerViewer",
            baseType: "content",
            typeLabel: "Book",
            allowedParents: [],
            defaultValue: {},
            childrenAttributes: ["content"]
        },
        "part": {
            form: "ContentContainerViewer",
            baseType: "content",
            typeLabel: "Part",
            allowedParents: ["book"],
            defaultValue: {},
            childrenAttributes: ["content"]
        },
        "chapter": {
            form: "ContentContainerViewer",
            baseType: "content",
            typeLabel: "Chapter",
            allowedParents: ["book", "part"],
            defaultValue: {},
            childrenAttributes: ["content"]
        },
        "scene": {
            form: "SceneViewer",
            baseType: "content",
            typeLabel: "Scene",
            allowedParents: ["book", "part", "chapter"],
            defaultValue: {},
            childrenAttributes: []
        },
        "note": {
            form: "NoteViewer",
            baseType: "note",
            typeLabel: "Note",
            defaultValue: {},
            childrenAttributes: ["subnotes"],
            allowedParents: ["note"]
        },
        "journal": {
            form: "JournalViewer",
            baseType: "journal",
            typeLabel: "Entry",
            defaultValue: {},
            childrenAttributes: [],
            allowedParents: [],
            initialize: function(item) {
                item.posted = dojo.date.locale.format(new Date(), {
                    selector: 'date',
                    formatLength: 'short'
                });
            }
        },
        "person": {
            form: "PersonViewer",
            baseType: "person",
            typeLabel: "Person",
            defaultValue: {},
            childrenAttributes: [],
            allowedParents: []
        },
        "place": {
            form: "PlaceViewer",
            baseType: "place",
            typeLabel: "Place",
            defaultValue: {},
            childrenAttributes: [],
            allowedParents: []
        },
        "thing": {
            form: "ThingViewer",
            baseType: "thing",
            typeLabel: "Thing",
            defaultValue: {},
            childrenAttributes: [],
            allowedParents: []
        },
        "goal": {
            form: "GoalViewer",
            baseType: "goal",
            typeLabel: "Goal",
            defaultValue: {},
            childrenAttributes: [],
            allowedParents: []
        }
    },
    
    genericDataStoreTypeMap: {
        "Date": Date,
        "Tags": { // TODO: Actually, can I change this to just use an array of strings?
            // Supposedly the data store should accept that with the 'getValues' thing.
            // How do I try it?
            type: TagList,
            deserialize: function(value) {
                return new TagList(value);
            },
            serialize: function(value) {
				debugger;
                return value.serialize();
            }
        }
    },
    
    constructor: function() {
        this.isOpen = false;
        this.isDirty = false;
        this.ReadOnly = true;
        
        this.ProjectStore = new dojo.data.ItemFileWriteStore({
            data: this._createProjectData(),
            typeMap: this.genericDataStoreTypeMap
        });
        // add save action
        var projectData = this;
        
        this.ProjectStore._serializeValue = function(/* anything */value) {
            // Similar to ItemFileReadStore._flatten, except
            // only items found at the toplevel are turned into references, the rest are returned
            // using _serializeItem.
            
            if (this.isItem(value)) {
				var item = value;
				if (dojo.indexOf(this._arrayOfTopLevelItems, item) == -1) {
					return this._serializeItem(item);
				} else {
					// Given an item, return an serializable object that provides a 
					// reference to the item.
					// For example, given kermit:
					//    var kermit = store.newItem({id:2, name:"Kermit"});
					// we want to return
					//    {_reference:2}
					var identity = this.getIdentity(item);
					var referenceObject = {
						_reference: identity
					};
					return referenceObject;
				}
            } else {
                if (typeof value === "object") {
                    for (var type in this._datatypeMap) {
                        var typeMap = this._datatypeMap[type];
                        if (dojo.isObject(typeMap) && !dojo.isFunction(typeMap)) {
                            if (value instanceof typeMap.type) {
                                if (!typeMap.serialize) {
                                    throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
                                }
                                return {
                                    _type: type,
                                    _value: typeMap.serialize(value)
                                };
                            }
                        } else if (value instanceof typeMap) {
                            //SImple mapping, therefore, return as a toString serialization.
                            return {
                                _type: type,
                                _value: value.toString()
                            };
                        }
                    }
                }
                return value;
            }
        }
        
        
        this.ProjectStore._serializeItem = function(item) {
            // Taken from ItemFileReadStore._getNewFileContentString, except:
            var serializableItem = {};
            for (var key in item) {
                if (key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName) {
                    var attribute = key;
                    var valueArray = this.getValues(item, attribute);
                    if (valueArray.length == 1) {
                        serializableItem[attribute] = this._serializeValue(valueArray[0]);
                    } else {
                        var serializableArray = [];
                        for (var j = 0; j < valueArray.length; ++j) {
                            serializableArray.push(this._serializeValue(valueArray[j]));
                        }
                        serializableItem[attribute] = serializableArray;
                    }
                }
            }
            return serializableItem;
            
        }
        
        this.ProjectStore._getFileContent = function() {
            // Similar to ItemFileReadStore._getNewFileContentString, except:
            // 1. Returns an actual JavaScript object, not a string.
			// 2. Only returns the items as an array, not the other stuff.
            // 3. Uses arrayOfTopLevelItems to start, and calls _serializeItem to do the serializing.
            // 4. Only items also appearing at arrayOfTopLevelItems are flattened, the rest are
            // included inline.
            var serializableItems = [];
            
            for (var i = 0; i < this._arrayOfTopLevelItems.length; ++i) {
                var item = this._arrayOfTopLevelItems[i];
                if (item !== null) {
                    var serializableItem = this._serializeItem(item);
                    serializableItems.push(serializableItem);
                }
            }
			return serializableItems;
            
        }
        this.ProjectStore._saveCustom = function(saveCompleteCallback, saveFailedCallback) {
            if (projectData._handler) {
                projectData.onBeginSave(projectData);
                try {
                    // FUTURE: Will someday need a mechanism for just getting changed items.
                    var getLookupValues = function(store) {
                        // NOTE: This requires the lookup stores to be ItemFileReadStores.
                        var result = [];
                        for (var i = 0; i < store._arrayOfAllItems.length; i++) {
                            result.push({
                                name: store.getValue(store._arrayOfAllItems[i], "name")
                            });
                        }
                        return result;
                    }
                    
                    var store = this;
                    
                    
                    var saver = {
                        GetSceneStatuses: function() {
                            return getLookupValues(projectData.Customizations.Scene.Statuses);
                        },
                        
                        GetSceneStructures: function() {
                            return getLookupValues(projectData.Customizations.Scene.Structures);
                        },
                        GetSceneImportances: function() {
                            return getLookupValues(projectData.Customizations.Scene.Importances);
                        },
                        GetSceneRatings: function() {
                            return projectData.Customizations.Scene.Ratings;
                        },
                        GetPersonRoles: function() {
                            return getLookupValues(projectData.Customizations.Person.Roles);
                        },
                        GetPersonImportances: function() {
                            return getLookupValues(projectData.Customizations.Person.Importances);
                        },
                        GetPersonRatings: function() {
                            return projectData.Customizations.Person.Ratings
                        },
                        GetInterfaceSettings: function() {
                            return projectData.InterfaceSettings;
                        },
                        GetEntities: function() {
                            return store._getFileContent();
                        }
                    }
                    projectData._handler.save(saver).then(function() {
                        saveCompleteCallback();
                        projectData.onEndSave(projectData);
                        
                    }, function(e) {
                        projectData.onSaveError(e);
                        saveFailedCallback(e);
                    });
                } catch (e) {
                    this.onSaveError(e);
                    saveFailedCallback(e);
                }
            }
        }
        
        // add triggers.
        this._connects = [dojo.connect(this.ProjectStore, "onSet", this, function(item, attribute, oldValue, newValue) {
            // make sure we don't end up in an infinite loop, and
            // make sure the item is actually set.
            if ((item) && (attribute != "modified")) {
                this.ProjectStore.setValue(item, "modified", new Date());
            }
        })];
        
        
    },
    
    destroy: function() {
        while (this._connects.length > 0) {
            dojo.disconnect(this._connects.pop());
        }
    },
    
    _createProjectData: function(items) {
        return {
            label: "name",
            identifier: "uid",
            items: items ||
            []
        }
    },
    
    CreateDataUID: function() {
        // NOTE: This requires Math.uuid.js.
        return Math.uuid(10);
    },
    
    _assertIsOpen: function() {
        if (!this.isOpen) {
            throw "Project Data has not been opened."
        }
    },
    
    NewDataItem: function(type, base, parentInfo) {
        this._assertIsOpen();
        if (this.TypeLookup.hasOwnProperty(type)) {
            if (this.TypeLookup[type].isAbstract) {
                throw "Can't create data item of type " + type;
            }
            if (!base) {
                // TODO: Perhaps we should really merge the objects instead.
                base = this.TypeLookup[type].defaultValue || {};
            }
            base.type = this.TypeLookup[type].baseType;
            if (type != base.type) {
                base.subtype = type;
            }
            base.uid = this.CreateDataUID();
            base.created = new Date();
            base.modified = new Date();
            if (!base.tags) {
                base.tags = new TagList();
            }
            if ((!base.name) && (base.name !== "")) {
                base.name = "New " + this.TypeLookup[type].typeLabel;
            }
            if (this.TypeLookup[type].initialize) {
                this.TypeLookup[type].initialize(base);
            }
            return this.ProjectStore.newItem(base, parentInfo);
        } else {
            throw "Invalid type for data item: " + type;
        }
    },
    
    _handler: null,
    
    _createIOHandler: function(uriString) {
        var scheme = uriString.split('://')[0];
        if (my.ProjectData.Drivers.hasOwnProperty(scheme)) {
            return my.ProjectData.Drivers[scheme](uriString, this);
        }
        return null;
    },
    
    _createNewProject: function(defaultName) {
        var now = new Date(); // for creating UID's.
        var me = this;
        var result = {
            IsReadOnly: function() {
                return false;
            },
            GetEntities: function() {
                return [{
                    created: now,
                    modified: now,
                    type: "project",
                    uid: "project",
                    name: defaultName,
                    credits: [{
						created: now,
						modified: now,
                        uid: me.CreateDataUID(),
                        role: "Author"
                    }]
                
                }]
            },
            // TODO: Come up with some useful defaults for these, so I can use them
            // until I allow them to be edited.
            GetSceneStatuses: function() {
                return [{
                    name: "draft"
                }, {
                    name: "reviewed"
                }, {
                    name: "ready"
                }]
            },
            GetSceneStructures: function() {
                return [{
                    name: "action"
                }, {
                    name: "reaction"
                }]
            },
            GetSceneImportances: function() {
                return [{
                    name: "plot"
                }, {
                    name: "subplot"
                }, {
                    name: "exposition"
                }]
            },
            GetSceneRatings: function() {
                return [{
                    name: "wordiness"
                }, {
                    name: "quality"
                }, {
                    name: "action"
                }, {
                    name: "beauty"
                }];
            },
            GetPersonRoles: function() {
                return [{
                    name: "protagonist"
                }, {
                    name: "antagonist"
                }, {
                    name: "bystander"
                }, {
                    name: "noncommitted"
                }];
            },
            GetPersonImportances: function() {
                return [{
                    name: "major"
                }, {
                    name: "supporting"
                }, {
                    name: "minor"
                }]
            },
            GetPersonRatings: function() {
                return [{
                    name: "depth"
                }, {
                    name: "realism"
                }, {
                    name: "sympathy"
                }, {
                    name: "likeability"
                }]
            },
            GetInterfaceSettings: function() {
                return {};
            }
        }
        return result;
        
    },
    
    SaveProject: function() {
        var result = new dojo.Deferred();
        try {
            this._assertIsOpen();
            if (this.ReadOnly) {
                throw "Project is Read Only!";
            }
            if (!this._handler) {
                throw "Project has no associated file.";
            }
            this.ProjectStore.save({
                onComplete: result.callback,
                onError: result.errback,
                scope: result
            });
        } catch (ex) {
            result.errback(ex);
        }
        return result;
    },
    
    _Revert: function() {
        // NOTE: This must be called before reloading new data when there
        // are unsaved changes.
        // TODO: Also revert any lookup data changes.
        this.ProjectStore.revert();
    },
    
    _LoadProject: function(formatHandler) {
        this.onBeginLoad(this);
        try {
            if (this.IsDirty()) {
                // We have to call revert first, otherwise the 
                // project store will raise an error when the data is refreshed.
                this._Revert();
            }
            this.ReadOnly = formatHandler.IsReadOnly();
            // NOTE: This is sort of a hack, as the object still supports
            // the API, but it can be used by less intelligent code
            // to simply turn off editing if readonly is true.
            this.ProjectStore._features['dojo.data.api.Write'] = !this.ReadOnly;
            this.ProjectStore._features['dojo.data.api.Notification'] = !this.ReadOnly;
            
            this.Customizations = {
                Scene: {
                    Statuses: new dojo.data.ItemFileReadStore({
                        data: {
                            label: "name",
                            identifier: "name",
                            items: formatHandler.GetSceneStatuses()
                        }
                    }),
                    Structures: new dojo.data.ItemFileReadStore({
                        data: {
                            label: "name",
                            identifier: "name",
                            items: formatHandler.GetSceneStructures()
                        }
                    }),
                    Importances: new dojo.data.ItemFileReadStore({
                        data: {
                            label: "name",
                            identifier: "name",
                            items: formatHandler.GetSceneImportances()
                        }
                    }),
                    Ratings: formatHandler.GetSceneRatings()
                
                },
                Person: {
                    Roles: new dojo.data.ItemFileReadStore({
                        data: {
                            label: "name",
                            identifier: "name",
                            items: formatHandler.GetPersonRoles()
                        }
                    }),
                    Importances: new dojo.data.ItemFileReadStore({
                        data: {
                            label: "name",
                            identifier: "name",
                            items: formatHandler.GetPersonImportances()
                        }
                    }),
                    Ratings: formatHandler.GetPersonRatings()
                
                }
            }
            this.InterfaceSettings = formatHandler.GetInterfaceSettings();
            
            // assign the project data here.
            // Have to jump through some hoops to 'refresh' the data.
            this.ProjectStore.clearOnClose = true;
            this.ProjectStore.data = this._createProjectData(formatHandler.GetEntities());
            this.ProjectStore.close();
            
            this.isOpen = true;
            this.onEndLoad(this);
            return true;
        } catch (e) {
            this.isOpen = false;
            this.ReadOnly = true;
            this.onLoadError(e);
            throw e;
        }
        
    },
    
    LoadProject: function(uriString, mightBeNew) {
        var result = new dojo.Deferred();
        // NOTE: This replaces everything. Make sure you save first.
        try {
            var handler = this._createIOHandler(uriString);
            if (!handler) {
                throw "Unimplemented: Can't retrieve project data from " + uriString;
            }
            var me = this;
            handler.load(mightBeNew &&
            function(name) {
                return me._createNewProject(name)
            }).then(function(formatHandler) {
                me._handler = handler;
                try {
                    me._LoadProject.apply(me, [formatHandler]);
                    result.callback();
                } catch (e) {
                    result.errback(e);
                }
            }, function(e) {
                result.errback(e);
            });
            
        } catch (e) {
            result.errback(e);
        }
        return result;
    },
    
    IsDirty: function() {
        // TODO: Also have to track the lookup data.
        return this.isDirty || this.ProjectStore.isDirty();
    },
    
    onBeginLoad: function() {
        // stub function for other objects to connect to.
    },
    
    onEndLoad: function() {
        // stub function for other objects to connect to.
    },
    
    onLoadError: function(e) {
        // stub function for other objects to connect to.
    
    },
    
    onBeginSave: function() {
        // stub function for other objects to connect to.
    },
    
    onEndSave: function() {
        // stub function for other objects to connect to.
    },
    
    onSaveError: function() {
        // stub function for other objects to connect to.
    },

    /* TODO: 
     * - methods for opening and saving file content attributes. This will load and save
     * depending on the mode, as mentioned above.
     *
     * - events for handling a change in mode (from writeable to read-only, for example,
     * or when a new item is loaded (one event before loading and one after, to allow
     * refreshing of trees, closing tabs, etc. prior to loading, and opening of
     * preferred tabs after).
     *
     * - methods for opening up a dialog box to search for a local file, but only under
     * certain circumstances.
     *
     */
});

/*
 *
 formatHandler.IsReadOnly();
 formatHandler.GetSceneStatuses()
 formatHandler.GetSceneStructures()
 formatHandler.GetSceneImportances()
 formatHandler.GetSceneRatings()
 formatHandler.GetPersonRoles()
 formatHandler.GetPersonImportances()
 formatHandler.GetPersonRatings()
 formatHandler.GetInterfaceSettings();
 formatHandler.GetEntities();
 */
// initialize the drivers array.
my.ProjectData.Drivers = {

    _projectEntityLoadFixup: function(entity) {
        if (entity.tags) {
			entity.tags = {
                _type: "Tags",
                _value: new TagList(entity.tags).serialize()
            }
            
        }
        if (entity.created) {
            entity.created = {
                _type: "Date",
                _value: entity.created
            }
        }
        if (entity.modified) {
            entity.modified = {
                _type: "Date",
                _value: entity.modified
            }
        }
        if (entity.subtype && entity.subtype == "scene") {
            if (entity.viewpoint) {
                entity.viewpoint = {
                    _reference: entity.viewpoint
                }
            }
            if (entity.setting) {
                entity.setting = {
                    _reference: entity.setting
                }
            }
            if (entity.people) {
                entity.people = dojo.map(entity.people, function(item) {
                    return {
                        _reference: item
                    }
                })
            }
            if (entity.places) {
                entity.places = dojo.map(entity.places, function(item) {
                    return {
                        _reference: item
                    }
                })
            }
            if (entity.things) {
                entity.things = dojo.map(entity.things, function(item) {
                    return {
                        _reference: item
                    }
                })
            }
            if (entity.ratings) {
                for (var i = 0; i < entity.ratings.length; i++) {
                    entity["rating" + i] = entity.ratings[i];
                }
                delete entity.ratings;
            }
        }
        if (entity.type == "person") {
            if (entity.ratings) {
                for (var i = 0; i < entity.ratings.length; i++) {
                    entity["rating" + i] = entity.ratings[i];
                }
                delete entity.ratings;
            }
        }
		return entity;
        
    },
    
    _projectEntitySaveFixup: function(entity) {
        if (entity.tags) {
            entity.tags = entity.tags._value;
        }
        if (entity.created) {
            entity.created = entity.created._value;
        }
        if (entity.modified) {
            entity.modified = entity.modified._value;
        }
        if (entity.subtype && entity.subtype == "scene") {
            if (entity.viewpoint) {
                entity.viewpoint = entity.viewpoint._reference;
            }
            if (entity.setting) {
                entity.setting = entity.setting._reference;
            }
            if (entity.people) {
                entity.people = dojo.map(entity.people, function(item) {
                    return item._reference;
                })
            }
            if (entity.places) {
                entity.places = dojo.map(entity.places, function(item) {
                    return item._reference;
                })
            }
            if (entity.things) {
                entity.things = dojo.map(entity.things, function(item) {
                    return item._reference;
                })
            }
            if (entity.rating0 || entity.rating1 || entity.rating2 || entity.rating3) {
                entity.ratings = [entity.rating0 || 0, entity.rating1 || 0, entity.rating2 || 0, entity.rating3 || 0];
            }
        }
        if (entity.type == "person") {
            if (entity.rating0 || entity.rating1 || entity.rating2 || entity.rating3) {
                entity.ratings = [entity.rating0 || 0, entity.rating1 || 0, entity.rating2 || 0, entity.rating3 || 0];
            }
        }
		return entity;
        
    },
    
    JSONFormatString: "manuscript-0.1",
    
    _writeStandardJSONFormat: function(dataReader) {
		debugger;
        var content = [];
        var notes = [];
        var journals = [];
        var people = [];
        var places = [];
        var things = [];
        var goals = [];
        var project = null;
        var entities = dataReader.GetEntities();
        for (var i = 0; i < entities.length; i++) {
            switch (entities[i].type) {
                case "content":
                    content.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "note":
                    notes.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "journal":
                    journals.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "person":
                    people.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "place":
                    places.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "thing":
                    things.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "goal":
                    goals.push(my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]));
                    break;
                case "project":
                    if (project) {
                        throw "Invalid project format."
                    }
                    project = my.ProjectData.Drivers._projectEntitySaveFixup(entities[i]);
                    break;
            }
        }
        var rawData = project;
        rawData.format = my.ProjectData.Drivers.JSONFormatString;
        rawData.content = content;
        rawData.notes = notes;
        rawData.journals = journals;
        rawData.people = people;
        rawData.places = places;
        rawData.things = things;
        rawData.goals = goals;
        
        rawData.interfaceSettings = dataReader.GetInterfaceSettings();
        
        var lookupEntityToString = function(value) {
            return value.name;
        }
        
        rawData.customizations = {
            scene: {
                statuses: dojo.map(dataReader.GetSceneStatuses(), lookupEntityToString),
                structures: dojo.map(dataReader.GetSceneStructures(), lookupEntityToString),
                importances: dojo.map(dataReader.GetSceneImportances(), lookupEntityToString),
                ratings: dojo.map(dataReader.GetSceneRatings(), lookupEntityToString)
            },
            person: {
                roles: dojo.map(dataReader.GetPersonRoles(), lookupEntityToString),
                importances: dojo.map(dataReader.GetPersonImportances(), lookupEntityToString),
                ratings: dojo.map(dataReader.GetPersonRatings(), lookupEntityToString),
            
            }
        };
        
        return dojo.toJson(rawData,true);
    },
    
    _readStandardJSONFormat: function(content) {
		debugger;
        var rawData = dojo.fromJson(content);
        // TODO: Should have a 'schema' to follow here and use dojox.json.schema.validate.
        // TODO: Come up with an appropriate format version string 		
        if ((rawData.format) && (rawData.format == my.ProjectData.Drivers.JSONFormatString)) {
            var entities = [];
            entities.push.apply(entities, dojo.map(rawData.content, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.content;
            entities.push.apply(entities, dojo.map(rawData.notes, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.notes;
            entities.push.apply(entities, dojo.map(rawData.journals, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.journals;
            entities.push.apply(entities, dojo.map(rawData.people, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.people;
            entities.push.apply(entities, dojo.map(rawData.places, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.places;
            entities.push.apply(entities, dojo.map(rawData.things, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.things;
            entities.push.apply(entities, dojo.map(rawData.goals, my.ProjectData.Drivers._projectEntityLoadFixup));
            delete rawData.goals;
            
            var customizations = rawData.customizations;
            delete rawData.customizations;
            var interfaceSettings = rawData.interfaceSettings;
            delete rawData.interfaceSettings;
            
            // The 'project' entity is the base of the format.
            entities.push(my.ProjectData.Drivers._projectEntityLoadFixup(rawData));
            
            var stringToLookupEntity = function(value) {
                return {
                    name: value
                };
            }
            
            return {
                IsReadOnly: function() {
                    return false;
                },
                GetSceneStatuses: function() {
                    return dojo.map(customizations.scene.statuses, stringToLookupEntity)
                },
                GetSceneStructures: function() {
                    return dojo.map(customizations.scene.structures, stringToLookupEntity)
                    
                },
                GetSceneImportances: function() {
                    return dojo.map(customizations.scene.importances, stringToLookupEntity)
                    
                },
                GetSceneRatings: function() {
                    return dojo.map(customizations.scene.ratings, stringToLookupEntity)
                    
                },
                GetPersonRoles: function() {
                    return dojo.map(customizations.person.roles, stringToLookupEntity)
                    
                },
                GetPersonImportances: function() {
                    return dojo.map(customizations.person.importances, stringToLookupEntity)
                    
                },
                GetPersonRatings: function() {
                    return dojo.map(customizations.person.ratings, stringToLookupEntity)
                    
                },
                GetInterfaceSettings: function() {
                    return interfaceSettings;
                },
                GetEntities: function() {
                    return entities;
                }
            }
        } else {
            throw "Invalid manuscript project format."
        }
    },
    
    file: function(uriString, ProjectData) {
    
        var FileIOHandler = function(uriString, httpFallback) {
        
            var fallback = false;
            var projectUri = uriString;
            var lockUri = uriString.substring(0, uriString.lastIndexOf('.')) + ".lock";
            
            // TODO: Possibly, set per-file permissions: http://www.mozilla.org/projects/security/components/per-file.html
            this.load = function(createNew) {
                //    If the application is on a file URL, then I can assume I
                //    *might* be able to get local file access and xdomain access.
                //    If it's not, then there's probably no way it will happen,
                //    although an advanced user may set some sort of advanced security
                //    privilege for a specific trusted site, so he can get it to work.
                // 1) If file is at a local file URI, then try to use
                //    TiddlyWiki method to 'save' a lock file and then
                //    load the file. If everything happens okay, then
                //    we can load the project data as writeable.
                // 2) If that fails, fallback to http, which uses xhrGet.
                if (my.LocalFileAccess) {
                    try {
                        // first, try to 'save' the lock file. If this raises an
                        // error, then we're falling back to http.
                        my.LocalFileAccess.save(my.LocalFileAccess.convertUriToLocalPath(lockUri), new Date().toString());
                        // if we can save, then we can load. From now on, any errors do not fall
                        // back to http anymore.
                        var result = new dojo.Deferred();
                        try {
                            projectFile = my.LocalFileAccess.convertUriToLocalPath(projectUri);
                            var data;
                            var content;
                            try {
                                content = my.LocalFileAccess.load(projectFile);
                            } catch (e) {
                                // TODO: If the file is not there, will I get an error, or will
                                // I get null content? This may differ based on platform. Until
                                // then, I'm assuming that if I get an error, the file doesn't exist.
                                // Only throw that error if I don't have a 'createNew'.
                                // -- Confirmation: Mozilla gives me 'null'.
                                // -- IE?
                                // -- Java?
                                if (createNew) {
                                    content = null;
                                } else {
                                    throw e;
                                }
                            }
                            if (content) {
                                data = my.ProjectData.Drivers._readStandardJSONFormat(content);
                            } else if (createNew) {
                                var defaultName = projectUri.substring(projectUri.lastIndexOf('/') + 1, projectUri.lastIndexOf('.'));
                                data = createNew(defaultName);
                            } else {
                                throw "Can't find file at " + projectFile;
                            }
                            result.callback(data);
                        } catch (e) {
                            result.errback(e);
                        }
                        return result;
                        
                        
                    } catch (ex) {
                        // can't load, so fallback to xhrGet.
                        fallback = true;
                        return httpFallback.load();
                    }
                } else {
                    // can't load, so fallback to xhrGet.
                    fallback = true;
                    return httpFallback.load();
                }
            }
            
            this.save = function(dataReader) {
                var result = new dojo.Deferred();
                try {
                    if (!fallback) {
                        var content = my.ProjectData.Drivers._writeStandardJSONFormat(dataReader);
                        var projectFile = my.LocalFileAccess.convertUriToLocalPath(projectUri);
                        my.LocalFileAccess.save(projectFile, content);
                        result.callback();
                    } else {
                        result.errback("Can't POST to local file.");
                    }
                } catch (ex) {
                    result.errback(ex);
                }
                return result;
            }
            
        }
        return new FileIOHandler(uriString, my.ProjectData.Drivers.http(uriString, ProjectData));
        
    },
    
    http: function(uriString, ProjectData) {
    
        var HttpIOHandler = function(uriString, httpFallback) {
        
            this.load = function() {
                // TODO: Need some way of specifying user and password if
                // the site implements security. I'd like to do a 'fallback'
                // where I get a status which indicates this and then ask
                // for the user and password, but it'd also be nice to be
                // able to pre-specify it.
                var xhr = dojo.xhrGet({
                    url: uriString,
                    handleAs: "json",
                    preventCache: true
                });
                var result = new dojo.Deferred(function() {
                    xhr.cancel();
                });
                xhr.then(function(content) {
                    try {
                        var data = my.ProjectData.Drivers._readStandardJSONFormat(content);
                        result.callback();
                    } catch (e) {
                        result.errback(e);
                    }
                }, function(err) {
                    result.errback(err);
                })
                return result;
            }
            
            
        }
        return new HttpIOHandler(uriString);
        
    },
    
    
    sample: function(uriString, ProjectData) {
        var SampleDatabases = {
            TheDarkHorizon: function(readOnly) {
                var now = new Date(); // for creating UID's.
                var result = {
                    IsReadOnly: function() {
                        return readOnly;
                    },
                    GetEntities: function() {
                        return [{
                            created: now,
                            modified: now,
                            type: "project",
                            uid: "project",
                            name: "Branch by Nigel",
                            description: "<p>A monumental foray into the desparate realms of cross-platform software development using HTML and JavaScript.</p>",
                            credits: [{
                                uid: ProjectData.CreateDataUID(),
                                name: "Neil M. Sheldon",
                                biography: "<p>Stunted by unprofessionalism, Neil has yet to publish a single word.</p>",
                                role: "Author"
                            }],
                        
                        }, {
                            uid: ProjectData.CreateDataUID(),
                            name: "The Dark Horizon...",
                            type: "content",
                            subtype: "book",
                            created: now,
                            modified: now,
                            tags: {
                                _type: "Tags",
                                _value: "[]"
                            },
                            content: [{
                                uid: ProjectData.CreateDataUID(),
                                name: "...And the brightness beyond.",
                                created: now,
                                modified: now,
                                type: "content",
                                subtype: "part",
                                tags: {
                                    _type: "Tags",
                                    _value: "[]"
                                },
                                content: [{
                                    uid: ProjectData.CreateDataUID(),
                                    created: now,
                                    modified: now,
                                    type: "content",
                                    subtype: "chapter",
                                    name: "And thus, it happened...",
                                    description: "<p>In which our hero begins his journey and destroys the chalice.</p>",
                                    tags: {
                                        _type: "Tags",
                                        _value: "[]"
                                    },
                                    content: [{
                                        uid: ProjectData.CreateDataUID(),
                                        created: now,
                                        modified: now,
                                        type: "content",
                                        subtype: "scene",
                                        name: "It was a Dark and Really Stormy Night",
                                        description: "<p>Our hero meets a dark stranger.</p>",
                                        tags: {
                                            _type: "Tags",
                                            _value: "[]"
                                        },
                                    }]
                                
                                }]
                            }]
                        }, {
                            uid: ProjectData.CreateDataUID(),
                            type: "note",
                            created: now,
                            modified: now,
                            tags: {
                                _type: "Tags",
                                _value: "[]"
                            },
                            name: "Here's the Truth about the Island."
                        
                        }]
                    },
                    GetSceneStatuses: function() {
                        return [{
                            name: "draft"
                        }, {
                            name: "reviewed"
                        }, {
                            name: "ready"
                        }]
                    },
                    GetSceneStructures: function() {
                        return [{
                            name: "action"
                        }, {
                            name: "reaction"
                        }]
                    },
                    GetSceneImportances: function() {
                        return [{
                            name: "plot"
                        }, {
                            name: "subplot"
                        }, {
                            name: "exposition"
                        }]
                    },
                    GetSceneRatings: function() {
                        return [{
                            name: "wordiness"
                        }, {
                            name: "quality"
                        }, {
                            name: "action"
                        }, {
                            name: "beauty"
                        }];
                    },
                    GetPersonRoles: function() {
                        return [{
                            name: "protagonist"
                        }, {
                            name: "antagonist"
                        }, {
                            name: "bystander"
                        }, {
                            name: "noncommitted"
                        }];
                    },
                    GetPersonImportances: function() {
                        return [{
                            name: "major"
                        }, {
                            name: "supporting"
                        }, {
                            name: "minor"
                        }]
                    },
                    GetPersonRatings: function() {
                        return [{
                            name: "depth"
                        }, {
                            name: "realism"
                        }, {
                            name: "sympathy"
                        }, {
                            name: "likeability"
                        }]
                    },
                    GetInterfaceSettings: function() {
                        return {};
                    }
                }
                return result;
                
            }
        }
        
        var SampleIOHandler = function(databaseName, readonly) {
        
            this.load = function() {
                var result = new dojo.Deferred();
                if (SampleDatabases.hasOwnProperty(databaseName)) {
                    var data;
                    try {
                        data = SampleDatabases[databaseName](readonly);
                    } catch (e) {
                        result.errback(e);
                        return result;
                    }
                    result.callback(data);
                } else {
                    result.errback("Unknown Sample Database Name: " + databaseName);
                }
                return result;
            }
            
            this.save = function(dataReader, success, error) {
                var result = new dojo.Deferred();
                // just eat all of the changes.
                if (readonly) {
                    result.errback("Can't save to this sample database.")
                } else {
                    result.callback();
                }
                return result;
            }
            
        }
        
        var parseUri = uriString.split('://');
        if (parseUri.length > 1) {
            path = parseUri[1].split('?');
            return new SampleIOHandler(path[0], path[1] && (path[1] == 'readonly=true'));
        }
        return null;
    }
};

